const puzzles = [
    {
        "name": "Checkerboard 20X20",
        "width": 20,
        "height": 20,
        "solutionSet": {
            "columns": [
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
            ],
            "rows": [
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
            ]
        },
        "solutionArray": [
            1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
            0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
            1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
            0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
            1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
            0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
            1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
            0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
            1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
            0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
            1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
            0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
            1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
            0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
            1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
            0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
            1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
            0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
            1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
            0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
        ]
    },
    {
        "name":"Which course is this for?",
        "width":"21",
        "height":"13",
        "solutionSet":{
            "columns":[[6,1,3],[1,1,1,1,1],[1,1,1,1,1],[1,1,4,1],[],[6,1],[1,1],[2,1,3],[1,1,1],[6,2],[],[6,6],[1,1,1,1,1],[1,1,1,1,1],[2,1,3],[],[1,4,1],[1],[6,4,1],[1],[1,4,1]],
            "rows":[[4,2,2,4,5],[1,1,1,1,1,1,1],[1,1,1,1,3,1],[1,1,1,1,1],[1,1,1,1,1],[4,1,1,1,1],[],[4,5,4,1,1,1],[1,1,1,1,1,1],[1,1,1,1,1,1],[4,1,4,1,1,1],[1,1,1,1],[4,1,4,1,1,1]]
        },
        "solutionArray":[1,1,1,1,null,1,1,0,1,1,null,1,1,1,1,null,1,1,1,1,1,1,null,null,null,null,1,null,1,null,1,0,1,null,null,1,null,null,null,1,null,null,1,null,null,null,null,1,null,1,null,1,0,1,1,1,0,null,null,null,1,null,null,1,null,null,null,null,1,null,null,null,1,0,1,null,0,0,null,null,null,1,null,null,1,null,null,null,null,1,null,null,null,1,null,1,null,null,null,null,null,null,1,null,null,1,1,1,1,null,1,null,null,null,1,null,1,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,1,1,1,null,1,1,1,1,1,null,1,1,1,1,null,1,null,1,null,1,null,null,null,1,null,null,null,null,0,1,null,1,null,null,null,null,1,null,1,null,1,null,null,null,1,null,null,null,0,1,0,null,1,null,null,null,null,1,null,1,null,1,1,1,1,1,null,null,0,1,0,null,null,1,1,1,1,null,1,null,1,null,1,1,null,null,null,null,null,0,1,null,null,null,1,null,0,1,null,0,null,null,null,null,1,1,1,1,null,null,0,1,null,null,null,1,1,1,1,null,1,null,1,null,1]
    }
]
class gameCanvas {
    constructor(puzzleObject) {
        this.width = puzzleObject.width;
        this.height = puzzleObject.height;
        this.size = this.width * this.height;
        this.matrix = new Array(this.size);
        this.solution = puzzleObject.solutionSet;
        this.topSecret = puzzleObject.solutionArray;
        this.drawState = {
            "drawing": false,
            "drawOrigin": null,
            "drawOriginActive": false,
            "fillMode": false
        }
    }
    //Renders table to element by ID
    drawTable(TableID) {
        let targetTable = document.getElementById(TableID);
        targetTable.innerHTML = "";
        targetTable.innerText = "";
        //Each square is 30*30, the table should be cols*30 px in width
        targetTable.style.width = `${100 + this.width * 30}px`

        //Header render
        let topRow = document.createElement("tr");
        topRow.classList.add("table-top");
        topRow.appendChild(document.createElement("th"));

        for (let x = 0; x < this.width; x++) {
            let tableHeader = document.createElement("th");
            tableHeader.classList.add("column-header");
            tableHeader.id = `col-${x}`;
            let tableHeaderList = document.createElement("ul");
            tableHeaderList.classList.add("column-header-list");
            tableHeader.appendChild(tableHeaderList);
            topRow.appendChild(tableHeader);
        }
        targetTable.appendChild(topRow);

        //Playgrid render
        for (let i = 0; i < this.height; i++) {
            let tableRow = document.createElement("tr");

            let tableHeader = document.createElement("th");
            tableHeader.classList.add("row-header");
            tableHeader.id = `row-${i}`;
            let tableHeaderList = document.createElement("ul");
            tableHeaderList.classList.add("row-header-list");
            tableHeader.appendChild(tableHeaderList);
            tableRow.appendChild(tableHeader);

            for (let j = 0; j < this.width; j++) {
                let tableCell = document.createElement("td");
                //tableCell.classList.add(`cell-${(this.width*i)+j}`);
                tableCell.id = `${(this.width * i) + j}`;
                tableCell.onmousedown = (e) => {
                    e.preventDefault();
                    this.drawState.drawing = true;
                    //If drawing on a blank cell make it active, if drawing on active erase it
                    this.drawState.fillMode = tableCell.classList.contains("active") ? false : true;
                    this.drawState.drawOrigin = tableCell.id;
                    this.drawState.drawOriginActive = tableCell.classList.contains("active");
                    this.makeActive(tableCell, this.drawState.fillMode);
                }
                tableCell.onmousemove = (e) => {
                    e.preventDefault();
                    if (this.drawState.drawing && this.drawState.drawOrigin != tableCell.id) {
                        if (this.drawState.fillMode && !tableCell.classList.contains("active")) {
                            this.makeActive(tableCell, true);
                        }
                        if (!this.drawState.fillMode && tableCell.classList.contains("active")) {
                            this.makeActive(tableCell, false);
                        }
                    }
                }
                tableCell.onmouseup = (e) => {
                    //Stop drawing when click is released and check against solution
                    this.drawState.drawing = false;
                    if (this.checkAgainstSolution()) {
                        alert("CONGRATULATIONS YOU CRACKED IT");
                    }
                }
                tableRow.appendChild(tableCell);
            }
            targetTable.appendChild(tableRow);
        }
        //If solution object is populated render the headers
        if (this.solution.hasOwnProperty("rows")) {
            this.renderHeader();
        }
        //Drawing Logic, if mouse leaves canvas drawing stops
        targetTable.onmouseleave = (e) => {
            this.drawState.drawing = false;
        }
    }

    makeActive(cell, active) {
        if (active) {
            cell.classList.add('active');
            this.matrix[cell.id] = 1;
        }
        else {
            cell.classList.remove('active');
            this.matrix[cell.id] = 0;
        }
    }

    reRender() {
        this.matrix.map((val, idx) => {
            if (val === 1) {   //If it is not active make it so
                if (!document.getElementById(idx).classList.contains('active')) {
                    document.getElementById(idx).classList.add('active');
                }
            }
            else //val == 0
            {   //If it is active make it not
                if (document.getElementById(idx).classList.contains('active')) {
                    document.getElementById(idx).classList.remove('active');
                }
            }
        });
    }

    resetCanvas() {
        //set grid to 0's (Blank Canvas)
        this.matrix.fill(0);
        this.reRender();
    }

    //Returns solution object by evaluating matrix array
    extractSolution() {
        if (!this.solution.hasOwnProperty("rows")) {
            return null;
        }
        //Get column vector counts
        var columnArr = [];

        for (let i = 0; i < this.width; i++) {
            let currentColArr = [];
            let currentCount = 0;
            //Evaluate each column pushing counts greater than 0 to specific column array
            for (let j = 0; j < this.height; j++) {
                if (this.matrix[(j * this.width) + i] == 1) {
                    currentCount++;
                } else {
                    if (currentCount > 0) {
                        currentColArr.push(currentCount);
                        currentCount = 0;
                    }
                }
            }
            //For the last cluster it reaches out of bounds and must be evaluated externally
            if (currentCount > 0) {
                currentColArr.push(currentCount);
                currentCount = 0;
            }
            //push each columns counts to the column array
            columnArr.push(currentColArr);
        }

        var rowArr = [];
        for (let i = 0; i < this.height; i++) {
            let currentRowArr = [];
            let currentCount = 0;
            //Evaluate each row pushing counts greater than 0 to specific row array
            for (let j = 0; j < this.width; j++) {
                if (this.matrix[(i * this.width) + j] == 1) {
                    currentCount++;
                } else {
                    if (currentCount > 0) {
                        currentRowArr.push(currentCount);
                        currentCount = 0;
                    }
                }
            }
            //For the last cluster it reaches out of bounds and must be evaluated externally
            if (currentCount > 0) {
                currentRowArr.push(currentCount);
                currentCount = 0;
            }
            //push each columns counts to the column array
            rowArr.push(currentRowArr);
        }

        return {
            "columns": columnArr,
            "rows": rowArr
        }
    }

    renderHeader() {
        //Map column counts to column headers
        this.solution.columns.map((arr, idx) => {
            //Always reset columns
            let targetHeader = document.getElementById(`col-${idx}`);
            //Get the ul element
            let listWrapper = targetHeader.firstElementChild;
            //Clear all elements in list
            listWrapper.innerHTML = "";
            //If not a blank array
            if (arr.length > 0) {
                arr.map(val => {
                    let listItem = document.createElement("li");
                    listItem.textContent = val;
                    listWrapper.appendChild(listItem);
                });
                targetHeader.appendChild(listWrapper);
            }
        });
        //Map row counts to row headers
        this.solution.rows.map((arr, idx) => {
            //Always reset counts
            let targetHeader = document.getElementById(`row-${idx}`);
            let listWrapper = targetHeader.firstElementChild;
            listWrapper.innerHTML = "";

            //If not a blank array
            if (arr.length > 0) {
                arr.map(val => {
                    let listItem = document.createElement("li");
                    listItem.textContent = val;
                    listWrapper.appendChild(listItem);
                });
                targetHeader.appendChild(listWrapper);
            }
        });
    }
    //Dynamically compares  matrix to solution set, as there are no guaranteed unique solutions
    checkAgainstSolution() {
        if (!this.solution.hasOwnProperty("rows")) {
            return false;
        }
        let currentState = this.extractSolution();
        let match = true;

        currentState.columns.map((arr, idx) => {
            //using array overriding for efficiency, if match is false, second statement skipped
            //if lengths match then check internal counts
            if (match && arr.length == this.solution.columns[idx].length) {
                //Only if lengths are non-zero do we access count array and compare items
                if (arr.length > 0) {
                    arr.map((val, arridx) => {
                        if (match && val != this.solution.columns[idx][arridx]) {
                            match = false;
                        }
                    });
                }
            } else {
                match = false;
            }
        });

        currentState.rows.map((arr, idx) => {
            //using array overriding for efficiency, if match is false, second statement skipped
            //if lengths match then check internal counts
            if (match && arr.length == this.solution.rows[idx].length) {
                //Only if lengths are non-zero do we access count array and compare items
                if (arr.length > 0) {
                    arr.map((val, arridx) => {
                        if (match && val != this.solution.rows[idx][arridx]) {
                            match = false;
                        }
                    });
                }
            } else {
                match = false;
            }
        });

        return match;
    }
    giveUp() {
        this.matrix = [...this.topSecret];
        this.reRender();
    }
};
//Puzzle list render

const renderPuzzleList = () => {
    let puzzleList = document.getElementById("puzzle-list");
    puzzleList.innerHTML = "";
    puzzles.map(obj => {
        let listItem = document.createElement("li");
        listItem.classList.add("puzzle-object");
        listItem.innerText = obj.name;
        listItem.onclick = () => {
            const puzzleCanvas = new gameCanvas(obj);
            puzzleCanvas.drawTable("draw-table");
            document.getElementById("giveup-button").removeAttribute("disabled");
            document.getElementById("reset-button").onclick = () => puzzleCanvas.resetCanvas();
            document.getElementById("giveup-button").onclick = () => puzzleCanvas.giveUp();
            if (document.getElementById("generation-span")) {
                document.getElementById("game-buttons").removeChild(document.getElementById("generation-span"));
            }

        };
        puzzleList.appendChild(listItem);
    });

    //Create new puzzle button with dimension input

    let createNewPuzzle = document.createElement("li");
    createNewPuzzle.classList.add("puzzle-object");
    createNewPuzzle.classList.add("new-puzzle");

    let xcoord = document.createElement("input");
    let ycoord = document.createElement("input");
    xcoord.id = "x-coord";
    ycoord.id = "y-coord";
    xcoord.classList.add("coord-input");
    ycoord.classList.add("coord-input");
    xcoord.setAttribute("type", "number");
    ycoord.setAttribute("type", "number");
    xcoord.setAttribute("value", 10);
    ycoord.setAttribute("value", 10);
    xcoord.setAttribute("max", 40);
    ycoord.setAttribute("max", 40);
    xcoord.setAttribute("min", 2);
    ycoord.setAttribute("min", 2);

    let inputSpan = document.createElement("span");
    let inputSpanText = document.createElement("span")
    inputSpanText.innerText = " by ";
    inputSpan.appendChild(xcoord);
    inputSpan.appendChild(inputSpanText);
    inputSpan.appendChild(ycoord);

    createNewPuzzle.appendChild(inputSpan);

    let newPuzzleButton = document.createElement("button");
    newPuzzleButton.onclick = () => {
        let xc = document.getElementById("x-coord").value;
        let yc = document.getElementById("y-coord").value;
        let puzzleObject = {
            "name": "",
            "width": xc,
            "height": yc,
            "solutionSet": {
                "columns": [],
                "rows": []
            },
            "solutionArray": []
        }
        const newPuzzleCanvas = new gameCanvas(puzzleObject);
        newPuzzleCanvas.drawTable("draw-table");
        document.getElementById("reset-button").onclick = () => newPuzzleCanvas.resetCanvas();
        document.getElementById("giveup-button").setAttribute("disabled", true);
        //Overwrite function in creation mode
        newPuzzleCanvas.checkAgainstSolution = () => false;

        //Input to name new puzzle
        let puzzleName = document.createElement("input");
        puzzleName.id = "puzzle-name";
        //Default value is puzzle #x
        puzzleName.setAttribute("value", `Puzzle #${puzzles.length}`)
        //Generate puzzle, adds puzzle to list on top;
        let generateButton = document.createElement("button");
        generateButton.id = "generate-button";
        generateButton.onclick = () => {
            puzzles.push({
                "name": document.getElementById("puzzle-name").value,
                "width": newPuzzleCanvas.width,
                "height": newPuzzleCanvas.height,
                "solutionSet": newPuzzleCanvas.extractSolution(),
                "solutionArray": [...newPuzzleCanvas.matrix]
            });
            renderPuzzleList();
            puzzleName.setAttribute("value", `Puzzle #${puzzles.length}`);
        }
        generateButton.innerText = "Create";

        let newPuzzleWrapper = document.createElement("span");
        newPuzzleWrapper.appendChild(puzzleName)
        newPuzzleWrapper.appendChild(generateButton);
        newPuzzleWrapper.id = "generation-span";

        let existingWrapper = document.getElementById("generation-span");
        let gameButtons = document.getElementById("game-buttons");
        if (existingWrapper) {
            gameButtons.removeChild(existingWrapper);
        }
        gameButtons.appendChild(newPuzzleWrapper);
    }
    newPuzzleButton.innerText = "Create New";

    createNewPuzzle.appendChild(newPuzzleButton);



    puzzleList.appendChild(createNewPuzzle);
}

//Generate list
renderPuzzleList();
